### 第九章
#### 代码评审
作者:汤姆·曼斯瑞克和凯特琳·萨多夫斯基
丽莎·凯里编辑
代码评审是指在将代码引入代码库之前，由作者以外的人审查的过程。虽然这是一个简单的定义，但是代码评审过程的实现在整个软件行业中有很大的不同。一些组织在代码库中有一组经过选择的“把关者”，他们负责审查变更。其他人将代码评审过程委托给较小的团队，允许不同的团队需要不同级别的代码评审。在谷歌，基本上每一个变更在提交之前都会被审查，每个工程师都负责发起审查和审查变更。
代码评审通常需要一个过程和支持该过程的工具的组合。在谷歌，我们使用定制的代码评审工具Critique来支持我们的流程。Critique在谷歌是一个足够重要的工具，在本书中有一整个章节来介绍它。本章着重于代码评审的过程，因为它是在谷歌而不是在特定的工具上实践的，这既是因为这些基础比工具更古老，也是因为这些见解中的大多数可以适用于您可能用于代码评审的任何工具。

代码评审的一些好处，比如在代码进入代码库之前检测代码中的错误，已经很好地建立起来了，并且有些明显(如果测量不精确的话)。然而，其他好处则更加微妙。因为谷歌的代码评审过程是如此的普遍和广泛，我们已经注意到了许多这些更微妙的影响，包括心理影响，这些影响随着时间和规模的推移给组织带来了许多好处。
#### 代码评审流程
代码评审可以发生在软件开发的许多阶段。在谷歌，在代码库发生变化之前需要进行代码评审；这一阶段也被称为预提交评审。代码评审的主要最终目标是让另一个工程师同意变更，我们通过将变更标记为“在我看来不错”(LGTM)来表示。我们使用LGTM作为必要的许可“位”(与下面提到的其他位相结合)，以允许提交更改。
谷歌的典型代码评审包括以下步骤:
1.用户在其工作空间中向代码库写入更改。然后作者创建了一个变更的快照:一个补丁和相应的描述被上传到代码评审工具。这种变化产生了与代码库之间的差异，代码库用于评估哪些代码发生了变化。
2.作者可以使用这个初始补丁来应用自动评论或进行自我评论。当作者对变更的差异感到满意时，他们会将变更发送给一个或多个审阅者。该过程通知这些审阅者，要求他们查看快照并对其进行评论。
3.审阅者在代码审阅工具中打开更改，并在diff上写上注释。一些评论要需要指出明确的解决办法。有些只是信息性的。
4.作者根据反馈修改变更并上传新的快照，然后回复给审阅者。步骤3和4可以重复多次。
5.在评审者对最新的变化状态感到满意后，他们通过标记“在我看来很好”来表示接受(LGTM)。默认情况下，只需要一个LGTM，尽管惯例可能会要求所有审查者同意更改。
6.只要作者解决了所有的注释标明的问题并且该变更被标记为LGTM之后，他们就可以将该变更提交给代码库。我们将在下一节讨论批准。
我们将在本章后面更详细地讨论这个过程。
#### 代码是一种责任
重要的是要记住(并接受)代码本身是一种责任。这可能是一项必要的责任，但就其本身而言，代码对某些人来说只是一项维护任务。很像飞机携带的燃料，它有重量，却是飞机飞行所必需的。
当然，新特性通常是必要的，但是在开发代码之前，首先应该小心谨慎，以确保任何新特性都是有保证的。重复的代码不仅是一种浪费大家精力的事情，实际上比不写代码还要花费更多的时间；当代码库中存在重复时，会导致在一种代码模式下很容易执行的更改，通常需要更多的工作。写全新的代码是如此令人不快，以至于有些人说“如果你从头开始写，那你就做错了！”
库或实用程序代码尤其如此。很有可能，如果你正在编写一个应用程序，像谷歌这么大的代码库中的某个人可能也做过类似的事情。因此，第17章中讨论的工具对于找到这样的实用程序代码和防止引入重复代码都是至关重要的。理想情况下，这项研究是事先完成的，在编写任何新代码之前，任何新的设计都已经传达给了适当的团队。
当然，会出现新的的项目，引入新的技术，需要新的组件等等。综上所述，代码评审不是重复或讨论先前设计决策的机会。设计决策通常需要时间，需要重复审查设计方案建议，在应用编程接口评审或类似会议中对设计进行辩论，以及原型的开发。除了不应突然对全新的代码进行代码评审外，代码评审过程本身也不应该被看作是一个重新审视以前决策的机会。
谷歌代码评审是如何工作的
#### 谷歌代码评审是如何工作的
我们已经大致指出了典型的代码评审过程是如何工作的，但是很多问题都出现在细节上。本节详细概述了代码评审在谷歌是如何工作的，以及这些实践如何允许它随着时间的推移适当地扩展。
在谷歌有三个方面的任何特定修改都需要“批准”的审查：
代码所有者之一批准该代码适用于代码库的这一特定部分(并且可以检查到特定目录中)。如果作者是这样的所有者，这种认可可能是隐含的。谷歌的代码库是一个树形结构，拥有特定目录的分层所有者。(见第16章)。所有者充当他们特定目录的看门人。任何工程师都可以提议修改，任何其他工程师都可以修改LGTM，但是有问题的目录的所有者也必须批准将这一部分添加到他们的代码库中。这样的所有者可能是技术主管或其他被认为是代码库特定领域专家的工程师。通常由每个团队决定分配所有权权限的范围。
具有语言“可读性”的人对代码符合语言风格和最佳实践的认可，检查代码是否按照我们期望的方式编写。如果作者有这样的可读性，这种认可也可能是隐含的。这些工程师是从全公司范围内拥有该编程语言可读性的工程师中挑选出来的。
虽然这种级别的控制听起来很麻烦——不可否认，有时确实如此——但大多数审查都是由一个人承担这三个角色，这就大大加快了进程。重要的是，作者也可以承担后两个角色，只需要另一个工程师的LGTM就可以将代码检查到他们自己的代码库中，前提是他们已经有了该语言的可读性(业主往往如此)。
这些需求使得代码评审过程非常灵活。一个技术负责人是一个项目的所有者，并且拥有该代码的语言可读性，他可以提交一个代码修改，只需要另一个工程师的LGTM。一个没有这种权力的实习生可以提交同样的修改到同一个代码库，只要他们得到一个拥有语言可读性的所有者的批准。上述三个许可 "位 "可以以任何组合结合。
在实践中，大多数需要一个以上批准的代码评审通常要经过两个步骤：从同行工程师那里获得LGTM，然后从适当的代码所有者/可读性审查者那里寻求批准。这使得两个角色可以专注于代码评审的不同方面，并节省审查时间。 首席审查员可以专注于代码的正确性和代码修改的一般有效性；代码所有者可以专注于这个修改是否适合他们的代码库的一部分，而不必专注于每一行代码的细节。换句话说，批准者通常在寻找与同行审查员不同的东西。"这段代码容易还是难以维护？""它是否增加了我的技术债务？""我们的团队中是否有维护它的专业知识？"
如果这三种类型的审查都可以由一个审查员来处理，为什么不直接让这些类型的审查员来处理所有的代码评审呢？简短的回答是规模。将这三种角色分开，可以增加代码评审过程的灵活性。 如果你和同行一起在一个实用程序库中开发一个新的函数，你可以让你团队中的某人来审查代码的正确性和可读性。经过几轮（可能是几天），你的代码满足了你的同行审查者，你得到了LGTM.现在，你只需要让库的所有者（而所有者往往有适当的可读性）批准这个变化。
#### 所有权 
当一个小团队在一个专门的资源库中工作时，通常会授予整个团队对资源库中所有内容的访问权。毕竟，你认识其他的工程师，这个领域很窄，你们每个人都可以成为专家，而且人数少会限制潜在错误的影响。
在谷歌，我们把这套知识和责任称为所有权，并把行使这些知识和责任的人称为所有者。这个概念不同于对源代码集合的占有，而是意味着一种管理意识，以公司的最佳利益对代码库的某个部分采取行动。
特别命名的OWNERS文件列出了对一个目录及其子目录有所有权责任的人的用户名。这些文件也可能包含对其他OWNERS文件或外部访问控制列表的引用，但最终它们会解析为一个个人列表。 每个子目录也可以包含一个单独的OWNERS文件，而且这种关系是分层递增的：一个给定的文件通常由目录树中它上面的所有OWNERS文件的成员联合拥有。OWNERS文件可以有任何团队喜欢的条目，但我们鼓励一个相对较小和集中的列表以确保责任明确。
对谷歌代码的所有权传达了对其权限范围内的代码的批准权，但这些权利也伴随着一系列的责任，如了解所拥有的代码或知道如何找到了解的人。不同的团队有不同的标准来授予新成员的所有权，但我们一般鼓励他们不要把所有权作为一种入会仪式，并鼓励离任的成员在可行的情况下尽快放弃所有权。
这种分布式所有权结构使我们在本书中列出的许多其他做法成为可能。例如，根OWNERS文件中的一组人可以作为大规模修改的全球批准者（见第22章），而不必打扰本地团队。同样，OWNERS文件作为一种文档，使人们和工具很容易找到对某段代码负责的人，只要在目录树上查找即可。 当创建新的项目时，没有中央机构需要注册新的所有权权限：一个新的OWNERS文件就足够了。这种所有权机制简单而强大，在过去的二十年中得到了很好的扩展。它是Google确保数以万计的工程师能够在一个库中的数十亿行代码上有效运作的方法之一。
#### 代码评审好处
在整个行业中，代码评审本身并没有争议，尽管它不是一种普遍的做法。许多（甚至可能是大多数）其他公司和开源项目都有某种形式的代码评审，而且大多数人认为这个过程很重要，是对将新代码引入代码库的理智检查。软件工程师理解代码评审的一些更明显的好处，即使他们个人可能不认为它适用于所有情况。但在谷歌，这个过程通常比大多数其他公司更彻底和广泛。
谷歌的文化，就像很多软件公司一样，是建立在给工程师广泛的自由度来完成他们的工作的基础上的。人们认识到，对于一个需要快速响应新技术的动态公司来说，严格的流程往往不能很好地工作，而官僚主义的规则往往不能很好地与创造性的专业人士合作。 谷歌要求对代码库中几乎所有的代码修改进行代码评审，无论多么小。这个任务确实对工程速度有成本和影响，因为它确实减缓了将新代码引入代码库的速度，并可能影响任何特定代码修改的生产时间。那么，为什么我们需要这个过程？为什么我们相信这是一个长期的好处？

